// <coroutine> -*- C++ -*-

#pragma once

#include <atomic>
#include <chrono>
#include <coroutine>

#include "common"
#include "event_loop"
#include "timer"

// Task type for C++ coroutines, suitable for use on Flipper.
// Not using any Furi naming, since it is unrelated to
// Furi primitives or FreeRTOS coroutines.
// cookie::Task<T> is to be used as a generic return object from a coroutine,
// you'll probably want to use it unless you need something more specialized.
// cookie::SkippableTask<T> spawns a timer (or event loop timer) that can be used
// to asynchronously delay the coroutine, with an option to skip early.
namespace cookie {

namespace details::coroutine {

template <typename T>
concept is_timer_type = std::same_as<T, FuriTimer> || std::same_as<T, FuriEventLoopTimer>;

template <typename T>
struct timer_start_stop;

template <>
struct timer_start_stop<::FuriTimer*> {
    static void start(::FuriTimer* timer, uint32_t interval) {
        ::furi_timer_start(timer, interval);
    }

    static void stop(::FuriTimer* timer) {
        ::furi_timer_stop(timer);
    }
};

template <>
struct timer_start_stop<::FuriEventLoopTimer*> {
    static void start(::FuriEventLoopTimer* timer, uint32_t interval) {
        ::furi_event_loop_timer_start(timer, interval);
    }

    static void stop(::FuriEventLoopTimer* timer) {
        ::furi_event_loop_timer_stop(timer);
    }
};

}

// Coroutine return type
// TODO: Support return types! For now, this is a void task
struct Task {
    struct promise_type;
    using handle_type = std::coroutine_handle<promise_type>;

    struct promise_type {
        Task get_return_object() {
            return Task(handle_type::from_promise(*this));
        }
        std::suspend_always initial_suspend() {
            return {};
        }
        std::suspend_always final_suspend() {
            return {};
        }
        void unhandled_exception() {
        }
        void return_void() {
        }
    };

    Task(handle_type handle)
        : m_handle(handle) {
    }
    Task(const Task&) = delete;
    ~Task() {
        m_handle.destroy();
    }

private:
    handle_type m_handle;
};

// Skippable and awaitable task
// Can co_yield on std::chrono::milliseconds. Waits can be skipped by calling .skip().
// This task should be stored somewhere (class member, preferably) so the lifetime is explicit.
// Template parameter specifies the timer primitive to use
// TODO: As with Task<T>, support return types. Remember the result may not be ready if skipped!
template <details::coroutine::is_timer_type T>
struct SkippableTask {
    struct promise_type;
    using handle_type = std::coroutine_handle<promise_type>;
    using timer_type = T;

    struct promise_type {
        promise_type()
        requires std::same_as<T, FuriTimer>
            : m_await_timer(
                  timeout_callback,
                  FuriTimerTypeOnce,
                  handle_type::from_promise(*this).address()) {
        }

        promise_type(::FuriEventLoop* event_loop)
        requires std::same_as<T, FuriEventLoopTimer>
            : m_await_timer(
                  event_loop,
                  timeout_callback,
                  FuriEventLoopTimerTypeOnce,
                  handle_type::from_promise(*this).address()) {
        }

        // Weird overload for non-static coroutines, we don't need the 'this' pointer,
        // but we can't really ignore it more gracefully
        promise_type([[maybe_unused]] auto ignored, ::FuriEventLoop* event_loop)
        requires std::same_as<T, FuriEventLoopTimer>
            : promise_type(event_loop) {
        }

        SkippableTask get_return_object() {
            return SkippableTask(handle_type::from_promise(*this));
        }
        std::suspend_never initial_suspend() {
            return {};
        }
        std::suspend_always final_suspend() {
            return {};
        }
        void unhandled_exception() {
        }
        void return_void() {
        }

        auto yield_value(std::chrono::milliseconds interval) {
            struct AwaitDelayAwaiter {
                AwaitDelayAwaiter(uint32_t interval, std::coroutine_handle<promise_type> handle)
                    : m_interval(interval)
                    , m_handle(handle) {
                }

                bool await_ready() const {
                    bool result =
                        (m_handle.promise().m_state_flags.load(std::memory_order_acquire) &
                         StateFlags::Skipped) != 0;
                    return result;
                }

                bool await_suspend(std::coroutine_handle<> h) {
                    UNUSED(h);
                    promise_type& promise = m_handle.promise();
                    uint8_t expected = 0;
                    if(!promise.m_state_flags.compare_exchange_strong(
                           expected, StateFlags::Suspended, std::memory_order_acquire)) {
                        // Task has been skipped
                        return false;
                    }
                    details::coroutine::timer_start_stop<decltype(*promise.m_await_timer)>::start(
                        *promise.m_await_timer, m_interval);
                    return true;
                }

                bool await_resume() const {
                    return (m_handle.promise().m_state_flags.fetch_and(
                                ~StateFlags::Suspended, std::memory_order_release) &
                            StateFlags::Skipped) == 0;
                }

            private:
                uint32_t m_interval;
                std::coroutine_handle<promise_type> m_handle;
            };
            return AwaitDelayAwaiter(interval.count(), handle_type::from_promise(*this));
        }

        static void timeout_callback(void* context) {
            handle_type handle = handle_type::from_address(context);
            if((handle.promise().m_state_flags.load(std::memory_order_acquire) &
                StateFlags::Skipped) == 0) {
                handle.resume();
            }
        }

        timer_type m_await_timer;

        enum StateFlags : uint8_t {
            Suspended = 1 << 0,
            Skipped = 1 << 1,
        };
        IMPLEMENT_FRIEND_BITWISE_ENUM_CLASS_OPS(StateFlags)

        std::atomic<uint8_t> m_state_flags{};
    };

    SkippableTask() = default;
    SkippableTask(handle_type handle)
        : m_handle(handle) {
    }
    SkippableTask(const SkippableTask&) = delete;
    SkippableTask(SkippableTask&& other)
        : m_handle(std::exchange(other.m_handle, nullptr)) {
    }
    SkippableTask& operator=(SkippableTask&& other) {
        // Maybe not the best idea to destroy the existing coroutine
        // by force, but that should be extremely rare to begin with.
        // Think of something better later, maybe.
        if(m_handle) {
            m_handle.destroy();
        }
        m_handle = std::exchange(other.m_handle, nullptr);
        return *this;
    }

    ~SkippableTask() {
        if(m_handle) {
            m_handle.destroy();
        }
    }

    void Skip() {
        if(m_handle) {
            if(!m_handle.done() &&
               m_handle.promise().m_state_flags.fetch_or(
                   promise_type::StateFlags::Skipped, std::memory_order_acquire) ==
                   promise_type::StateFlags::Suspended) {
                m_handle.resume();
            }
        }
    }

private:
    handle_type m_handle;
};

}
