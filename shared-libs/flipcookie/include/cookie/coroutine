// <coroutine> -*- C++ -*-

#pragma once

#include <atomic>
#include <coroutine>

#include "common"
#include "event_loop"
#include "timer"

// Task type for C++ coroutines, suitable for use on Flipper.
// Not using any Furi naming, since it is unrelated to
// Furi primitives or FreeRTOS coroutines.
namespace cookie {

namespace details::coroutine {

template <typename T>
concept is_timer_type = std::same_as<T, FuriTimer> || std::same_as<T, FuriEventLoopTimer>;

// Workaround for the lack of `furi_event_loop_timer_get_owner()` - empty class for FuriTimer,
// a class storing FuriEventLoop* for FuriEventLoopTimer
template <typename T>
struct event_loop_field {};

template <>
struct event_loop_field<::FuriEventLoopTimer*> {
    event_loop_field(::FuriEventLoop* event_loop)
        : m_event_loop(event_loop) {
    }

    ::FuriEventLoop* m_event_loop;
};

template <typename T>
struct timer_start_stop;

template <>
struct timer_start_stop<::FuriTimer*> {
    static void start(::FuriTimer* timer, uint32_t interval) {
        ::furi_timer_start(timer, interval);
    }

    static void stop(::FuriTimer* timer) {
        ::furi_timer_stop(timer);
    }

    static void pend(
        [[maybe_unused]] const event_loop_field<::FuriTimer*>& event_loop,
        FuriTimerPendigCallback callback,
        void* context,
        uint32_t arg = 0) {
        ::furi_timer_pending_callback(callback, context, arg);
    }
};

template <>
struct timer_start_stop<::FuriEventLoopTimer*> {
    static void start(::FuriEventLoopTimer* timer, uint32_t interval) {
        ::furi_event_loop_timer_start(timer, interval);
    }

    static void stop(::FuriEventLoopTimer* timer) {
        ::furi_event_loop_timer_stop(timer);
    }

    static void pend(
        const event_loop_field<::FuriEventLoopTimer*>& event_loop,
        FuriEventLoopPendingCallback callback,
        void* context,
        [[maybe_unused]] uint32_t arg = 0) {
        ::furi_event_loop_pend_callback(event_loop.m_event_loop, callback, context);
    }
};

}

// Awaitable timer type. Calling co_await obj.await_delay(interval) on it suspends the coroutine
// for a specified time, but can additionally also be woken up (e.g. from input) by calling obj.wake_up().
template <details::coroutine::is_timer_type T = FuriTimer>
class AwaitableTimer {
public:
    using timer_type = T;
    using timer_furi_type = typename timer_type::pointer;
    using event_loop_field = details::coroutine::event_loop_field<timer_furi_type>;
    using timer_start_stop = details::coroutine::timer_start_stop<timer_furi_type>;

    AwaitableTimer()
    requires std::same_as<timer_type, FuriTimer>
        : m_timer(timer_callback, FuriTimerTypeOnce, &m_awaiting_handle_ptr) {
    }

    AwaitableTimer(::FuriEventLoop* event_loop)
    requires std::same_as<timer_type, FuriEventLoopTimer>
        : m_timer(event_loop, timer_callback, FuriEventLoopTimerTypeOnce, &m_awaiting_handle_ptr)
        , m_event_loop(event_loop) {
    }

    void wake_up(bool keep_awake_forever = false) {
        StateFlags new_flags(StateFlags::Skipped);
        if(keep_awake_forever) {
            new_flags |= StateFlags::KeepAwakeForever;
        }
        m_state_flags.store(new_flags, std::memory_order_relaxed);

        timer_start_stop::stop(*m_timer);
        std::coroutine_handle<>* current_handle =
            m_awaiting_handle_ptr.exchange(nullptr, std::memory_order_relaxed);
        if(current_handle != nullptr) {
            timer_start_stop::pend(m_event_loop, timer_pend_callback, current_handle->address());
        }
    }

    auto await_delay(uint32_t interval) {
        struct AwaitDelayAwaiter {
            AwaitDelayAwaiter(AwaitableTimer* timer, uint32_t interval)
                : m_timer(timer)
                , m_interval(interval) {
            }

            bool await_ready() const {
                return m_timer->try_clear_skip_flag();
            }

            void await_suspend(std::coroutine_handle<> h) {
                m_awaiting_coroutine = h;
                m_timer->start(&m_awaiting_coroutine, m_interval);
            }

            bool await_resume() {
                const bool was_skipped = m_timer->stop();
                // Return true if timed out, false if skipped
                return !was_skipped;
            }

        private:
            std::coroutine_handle<> m_awaiting_coroutine;
            AwaitableTimer* m_timer;
            uint32_t m_interval;
        };
        return AwaitDelayAwaiter(this, interval);
    }

private:
    void start(std::coroutine_handle<>* handle_ptr, uint32_t interval) {
        m_awaiting_handle_ptr.store(handle_ptr, std::memory_order_relaxed);
        timer_start_stop::start(*m_timer, interval);
    }

    bool stop() {
        timer_start_stop::stop(*m_timer);
        m_awaiting_handle_ptr.store(nullptr, std::memory_order_relaxed);

        // Return true if the timer was skipped, either one-off or sticky
        return try_clear_skip_flag();
    }

    // Clear the Skipped flag if it's the only one and it's set, and check the previous flags
    bool try_clear_skip_flag() {
        uint8_t prev_flags = StateFlags::Skipped;
        m_state_flags.compare_exchange_strong(prev_flags, 0, std::memory_order_relaxed);
        return prev_flags != 0;
    }

    static void timer_callback(void* context) {
        auto handle_ptr = reinterpret_cast<std::atomic<std::coroutine_handle<>*>*>(context);
        std::coroutine_handle<>* current_handle =
            handle_ptr->exchange(nullptr, std::memory_order_relaxed);
        if(current_handle != nullptr) {
            current_handle->resume();
        }
    }

    static void timer_pend_callback(void* context) {
        std::coroutine_handle<> handle = std::coroutine_handle<>::from_address(context);
        handle.resume();
    }

    // Overload for FuriTimer*
    static void timer_pend_callback(void* context, [[maybe_unused]] uint32_t arg) {
        timer_pend_callback(context);
    }

private:
    enum StateFlags : uint8_t {
        Skipped = 1 << 0,
        KeepAwakeForever = 1 << 1,
    };
    IMPLEMENT_FRIEND_BITWISE_ENUM_CLASS_OPS(StateFlags)

    timer_type m_timer;
    // Workaround for the lack of furi_event_loop_timer_get_owner
    [[no_unique_address]] event_loop_field m_event_loop;
    std::atomic<std::coroutine_handle<>*> m_awaiting_handle_ptr{};
    std::atomic<uint8_t> m_state_flags{};
};

// Generic task type. Contrary to what is allowed in C++ apps targeting more elaborate systems,
// this return object MUST be stored somewhere, preferably an object. The lifetime of the coroutine
// is ALWAYS tied to the lifetime of this return object, fire-and-forget coroutines are NOT possible.
// TODO2: Support return values, right now only Task<void> is supported
template <typename T = void>
struct [[nodiscard("The task object must be stored")]] Task {
    struct promise_type;
    using handle_type = std::coroutine_handle<promise_type>;
    using return_type = T;

    // TODO: For now we only allow Task<void>
    static_assert(std::is_void_v<return_type>);

    struct promise_type {
        Task get_return_object() {
            return Task(handle_type::from_promise(*this));
        }
        std::suspend_never initial_suspend() {
            return {};
        }
        std::suspend_always final_suspend() {
            return {};
        }
        void unhandled_exception() {
        }
        void return_void() {
        }
    };

    Task() = default;
    Task(handle_type handle)
        : m_handle(handle) {
    }
    Task(const Task&) = delete;
    Task& operator=(const Task&) = delete;

    Task(Task&& other)
        : m_handle(std::exchange(other.m_handle, nullptr)) {
    }
    Task& operator=(Task&& other) {
        reset();
        m_handle = std::exchange(other.m_handle, nullptr);
        return *this;
    }

    ~Task() {
        reset();
    }

    void reset() {
        if(m_handle) {
            m_handle.destroy();
            m_handle = nullptr;
        }
    }

    bool is_active() const {
        return m_handle != nullptr && !m_handle.done();
    }

private:
    handle_type m_handle;
};

}
